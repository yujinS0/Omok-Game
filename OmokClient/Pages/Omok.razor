@page "/omok"
@using AntDesign
@using Blazored.SessionStorage
@using OmokClient.Services
@inject ISessionStorageService sessionStorage
@inject GameService GameService
@inject MessageService _message
@inject NavigationManager Navigation

<h3>Omok Game</h3>

<div class="wrapper">
    <div class="omok-container">
        <table class="omok-table">
            @for (int i = 0; i < 15; i++)
            {
                <tr>
                    @for (int j = 0; j < 15; j++)
                    {
                        var row = i;
                        var col = j;
                        <td>
                            <button @onclick="@(args => PutStone(row, col))" class="omok-button" onmouseover="this.style.border='2px solid #000'" onmouseout="this.style.border='1px solid #ccc'">
                                <img src="@GetStoneImage(row, col)" alt="stone" class="stone-img" />
                            </button>
                        </td>
                    }
                </tr>
            }
        </table>
    </div>
    <div class="info-container">
        <div class="info-item">흑돌: <span class="info-value">@blackPlayer</span></div>
        <div class="info-item">백돌: <span class="info-value">@whitePlayer</span></div>
        <div class="info-item">현재 차례: <span class="info-value red-text">@currentTurn</span></div>
        <div class="info-item">남은 시간: <span class="info-value">@remainingTime</span></div>
    </div>
</div>

@code {
    private OmokStone[,] board = new OmokStone[15, 15]; // 기본값으로 초기화
    private string playerId = string.Empty;
    private string blackPlayer = string.Empty;
    private string whitePlayer = string.Empty;
    private string currentTurn = string.Empty;
    private int remainingTime = 30;
    private bool isPollingActive = true;
    private bool isTimerRunning = false;
    // private CancellationTokenSource ctsTimer;

    protected override async Task OnInitializedAsync()
    {
        playerId = await sessionStorage.GetItemAsync<string>("sessionUserId") ?? string.Empty;

        blackPlayer = await sessionStorage.GetItemAsync<string>("blackPlayer") ?? string.Empty;
        whitePlayer = await sessionStorage.GetItemAsync<string>("whitePlayer") ?? string.Empty;

        if (string.IsNullOrEmpty(blackPlayer) || string.IsNullOrEmpty(whitePlayer))
        {
            blackPlayer = await GameService.GetBlackPlayerAsync(playerId);
            whitePlayer = await GameService.GetWhitePlayerAsync(playerId);
            await sessionStorage.SetItemAsync("blackPlayer", blackPlayer);
            await sessionStorage.SetItemAsync("whitePlayer", whitePlayer);
        }

        await LoadGameStateAsync();
        _ = StartTurnPollingAsync(); // 턴 확인을 위한 폴링 시작
    }

    // 자기 차례 X : 자신의 턴인지 체크하는 폴링
    private async Task StartTurnPollingAsync()
    {
        // remainingTime = 30; // 남은 시간을 30초로 설정
        // ctsTimer?.Cancel(); // 기존 타이머 작업 취소
        Console.WriteLine("== StartTurnPollingAsync ==");
        while (isPollingActive)
        {
            var currentTurnPlayerId = await GameService.CheckTurnAsync(playerId);
            if (string.IsNullOrEmpty(currentTurnPlayerId))
            {
                await Task.Delay(1000); // 현재 게임이 시작되지 않았으면 1초 대기
                continue;
            }

            currentTurn = (currentTurnPlayerId == blackPlayer) ? "black" : "white"; // 
            Console.WriteLine($"Current turn: {currentTurn}");
            await InvokeAsync(StateHasChanged); // UI 갱신을 보장

            // Check for winner
            var winnerResponse = await GameService.GetWinnerAsync(playerId);
            if (winnerResponse.Result == ErrorCode.None && winnerResponse.Winner != null)
            {
                string winnerMessage = winnerResponse.Winner.PlayerId == playerId
                    ? "축하합니다! 당신이 이겼습니다!"
                    : $"아쉽네요... {winnerResponse.Winner.PlayerId} 님이 이겼습니다.";
                await _message.Info(winnerMessage);
                isPollingActive = false;
                return;
            }

            // Load the board state (오목판 업데이트)
            await LoadGameStateAsync();

            if (currentTurnPlayerId == playerId)
            {
                Console.WriteLine("이제 내 차례!");
                Console.WriteLine($"Your turn: {currentTurn}");
                await InvokeAsync(StateHasChanged); // 자신의 차례가 되었을 때 UI를 갱신
                // _ = StartLongPollingAsync(); // 그리고 long polling 시작
                StartLongPolling();
                StartTimer();
                break;
            }

            await Task.Delay(1000); // 1초마다 턴 확인
        }
    }
    private void StartTimer()
    {
        remainingTime = 30;
        isTimerRunning = true;

        Task.Run(async () =>
        {
            while (remainingTime > 0 && isTimerRunning)
            {
                await Task.Delay(1000);
                remainingTime = Math.Max(0, remainingTime - 1);
                await InvokeAsync(StateHasChanged); // UI 갱신을 보장
            }

            if (remainingTime == 0)
            {
                isTimerRunning = false;
                // TODO: 타임아웃 처리 로직 추가
            }
        });
    }
    private void StopTimer()
    {
        isTimerRunning = false;
    }

    // 자기 차례 O : 시간 체크하는 30초 롱 폴링
    private void StartLongPolling()
    {
        remainingTime = 30; // 남은 시간을 30초로 설정
        // ctsTimer?.Cancel(); // 기존 타이머 작업 취소
        // ctsTimer = new CancellationTokenSource(); // 타이머를 취소용 CancellationTokenSource 생성

        // 타이머 작업
        Task.Run(async () =>
        {
            while (remainingTime > 0 && isPollingActive) // remainingTime이 0보다 크고 isPollingActive가 true인 동안 반복
            {
                await Task.Delay(1000); // 1초 대기
                remainingTime--; // 남은 시간을 1초 감소
                await InvokeAsync(StateHasChanged); // UI 갱신을 보장
            }
        }); // cts.Token을 전달하여 작업 취소 가능

        // 롱 폴링 작업
        _ = Task.Run(async () =>
        {
            try
            {
                var response = await GameService.WaitForTurnChangeAsync(playerId); // 서버에 턴 변화를 확인하는 요청
                if (response.Result == ErrorCode.None || response.Result == ErrorCode.TurnChangedByTimeout) // 응답이 성공적이거나 타임아웃인 경우
                {
                    if (response.GameInfo != null) // 응답에 게임 정보가 있는 경우
                    {
                        DecodeBoard(response.GameInfo.Board); // 게임 보드 상태를 디코드하여 업데이트
                        currentTurn = response.GameInfo.CurrentTurn.ToString().ToLower(); // 현재 턴을 업데이트
                        Console.WriteLine($"Turn changed: {currentTurn}");
                        await InvokeAsync(StateHasChanged); // UI 갱신을 보장

                        // 승자 확인
                        var winnerResponse = await GameService.GetWinnerAsync(playerId); // 서버에 승자 확인 요청
                        if (winnerResponse.Result == ErrorCode.None && winnerResponse.Winner != null) // 승자가 있는 경우
                        {
                            string winnerMessage = winnerResponse.Winner.PlayerId == playerId
                                ? "축하합니다! 당신이 이겼습니다!"
                                : $"아쉽네요... {winnerResponse.Winner.PlayerId} 님이 이겼습니다.";
                            await _message.Info(winnerMessage); // 승자 메시지를 사용자에게 표시
                            isPollingActive = false; // 폴링을 중지
                            // ctsTimer.Cancel(); // 타이머 취소
                            // remainingTime = 30;
                            return; // 함수 종료
                        }
                    }
                    _ = StartTurnPollingAsync(); // long polling이 끝나면 다시 턴 확인 시작
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in long polling: {ex.Message}"); // 예외 발생 시 콘솔에 로그 출력
                await Task.Delay(1000); // 오류 발생 시 1초 대기 후 재시도
                _ = StartTurnPollingAsync(); // 오류 발생 시 다시 턴 확인 시작
            }
        }); // cts.Token을 전달하여 작업 취소 가능
    }


    // // 자기 차례 O : 시간 체크하는 30초 롱 폴링
    // private async Task StartLongPollingAsync()
    // {
    //     try
    //     {
    //         remainingTime = 30;
    //         cts = new CancellationTokenSource();
    //         var timer = Task.Run(async () =>
    //         {
    //             while (remainingTime > 0 && isPollingActive)
    //             {
    //                 await Task.Delay(1000);
    //                 remainingTime--;
    //                 await InvokeAsync(StateHasChanged); // UI 갱신을 보장
    //             }
    //         });

    //         var response = await GameService.WaitForTurnChangeAsync(playerId);
    //         if (response.Result == ErrorCode.None || response.Result == ErrorCode.TurnChangedByTimeout)
    //         {
    //             if (response.GameInfo != null)
    //             {
    //                 DecodeBoard(response.GameInfo.Board);
    //                 currentTurn = response.GameInfo.CurrentTurn.ToString().ToLower();
    //                 Console.WriteLine($"Turn changed: {currentTurn}");
    //                 await InvokeAsync(StateHasChanged); // UI 갱신을 보장

    //                 // // Check for winner
    //                 // var winnerResponse = await GameService.GetWinnerAsync(playerId);
    //                 // if (winnerResponse.Result == ErrorCode.None && winnerResponse.Winner != null)
    //                 // {
    //                 //     string winnerMessage = winnerResponse.Winner.PlayerId == playerId
    //                 //         ? "축하합니다! 당신이 이겼습니다!"
    //                 //         : $"아쉽네요... {winnerResponse.Winner.PlayerId} 님이 이겼습니다.";
    //                 //     await _message.Info(winnerMessage);
    //                 //     isPollingActive = false;
    //                 //     return;
    //                 // }

    //             }
    //             _ = StartTurnPollingAsync(); // long polling이 끝나면 다시 턴 확인 시작
    //         }
    //     }
    //     catch (Exception ex)
    //     {
    //         Console.WriteLine($"Error in long polling: {ex.Message}");
    //         await Task.Delay(1000); // 오류 발생 시 1초 대기 후 재시도
    //         _ = StartTurnPollingAsync(); // 오류 발생 시 다시 턴 확인 시작
    //     }
    // }


    private async Task LoadGameStateAsync() // 게임 화면 업데이트
    {
        try
        {
            Console.WriteLine("== LoadGameStateAsync ==");

            var rawData = await GameService.GetBoardAsync(playerId);
            if (rawData != null)
            {
                DecodeBoard(rawData);
            }

            currentTurn = await GameService.GetCurrentTurnAsync(playerId);
            await InvokeAsync(StateHasChanged); // UI 갱신을 보장
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading game state: {ex.Message}");
        }
    }


    private async Task PutStone(int row, int col)
    {
        Console.WriteLine("== PlaceStone ==");

        if (board == null)
        {
            await _message.Error("오목판이 초기화되지 않았습니다.", 5);
            return;
        }

        if (row < 0 || row >= 15 || col < 0 || col >= 15 || board[row, col] != OmokStone.None)
        {
            return;
        }

        if ((currentTurn == "black" && playerId != blackPlayer) || (currentTurn == "white" && playerId != whitePlayer))
        {
            await _message.Error("당신의 차례가 아닙니다!!", 5);
            return;
        }

        // var success = await GameService.PlaceStoneAsync(playerId, col, row);
        // if (success)
        // {
        //     board[row, col] = playerId == blackPlayer ? OmokStone.Black : OmokStone.White;
        //     // Navigation.NavigateTo(Navigation.Uri, forceLoad: true); // 임시 : 돌 두기 성공 시 페이지 새로고침
        //                                                             // TODO long polling으로 체크해서 턴 바뀌면 새로고침하도록
        //                                                             // await LoadGameStateAsync();
        //     currentTurn = currentTurn == "black" ? "white" : "black";
        //     Console.WriteLine($"Placed stone, next turn: {currentTurn}");
        //     await InvokeAsync(StateHasChanged); // UI 갱신을 보장
        //     _ = StartTurnPollingAsync(); // 돌을 둔 후, 턴 확인 시작
        // }
        var response = await GameService.PutStoneAsync(playerId, col, row);
        if (response.Result == ErrorCode.None)
        {
            board[row, col] = playerId == blackPlayer ? OmokStone.Black : OmokStone.White;
            currentTurn = currentTurn == "black" ? "white" : "black";
            Console.WriteLine($"Placed stone, next turn: {currentTurn}");
            await InvokeAsync(StateHasChanged); // UI 갱신을 보장

            if (response.Winner != null)
            {
                string winnerMessage = response.Winner.PlayerId == playerId
                    ? "축하합니다! 당신이 이겼습니다!"
                    : $"아쉽네요... {response.Winner.PlayerId} 님이 이겼습니다.";
                await _message.Info(winnerMessage);
                isPollingActive = false;
                // ctsTimer.Cancel(); // 타이머 취소
                // remainingTime = 30;
                StopTimer();
                return;
            }
            StopTimer();
            _ = StartTurnPollingAsync(); // 돌을 둔 후, 턴 확인 시작
        }
    }

    private string GetStoneImage(int row, int col)
    {
        if (board == null || row < 0 || row >= 15 || col < 0 || col >= 15)
        {
            return "/images/empty.png"; // 배열 경계 검사 및 board가 null인 경우 처리
        }

        return board[row, col] switch
        {
            OmokStone.Black => "/images/black_stone.png",
            OmokStone.White => "/images/white_stone.png",
            _ => "/images/empty.png"
        };
    }

    private void DecodeBoard(byte[] rawData)
    {
        if (rawData != null)
        {
            Console.WriteLine($"Raw data length: {rawData.Length}");
            Console.WriteLine($"Raw data: {BitConverter.ToString(rawData)}");
        }
        else
        {
            Console.WriteLine("Raw data is null.");
        }

        if (rawData != null && rawData.Length >= 15 * 15)
        {
            Console.WriteLine("Decoding board...");

            board = new OmokStone[15, 15];
            for (int y = 0; y < 15; y++)
            {
                for (int x = 0; x < 15; x++)
                {
                    board[y, x] = (OmokStone)rawData[y * 15 + x];
                    Console.WriteLine($"Stone at ({x}, {y}): {board[y, x]}");
                }
            }
        }
        else
        {
            Console.WriteLine("Invalid raw data length or raw data is null. Initializing board to default.");

            // 데이터가 올바르지 않은 경우 기본값으로 초기화
            board = new OmokStone[15, 15];
        }

        Console.WriteLine("Board decoding complete.");
    }
}

<style>
    h3 {
        font-family: 'Arial', sans-serif;
        font-size: 3em;
        font-weight: bold;
        color: #2c3e50;
    }

    p {
        font-family: 'Verdana', sans-serif;
        font-size: 1.2em;
        font-weight: normal;
        line-height: 1.5;
        color: #7f8c8d;
    }

    body {
        margin: 0;
        padding: 0;
        background-color: #FFF8DC; /* 페이지 전체 배경 색상 */
        overflow: hidden;
    }

    .wrapper {
        display: flex;
        justify-content: flex-start; /* 왼쪽 정렬 */
        align-items: flex-start; /* 위쪽 정렬 */
        height: 100vh;
        width: 100%;
        padding: 20px; /* 원하는 여백 설정 */
    }

    .info-container {
        width: 300px;
        max-width: 20vw; /* 최대 너비 설정 */
        margin-bottom: 20px;
        padding: 10px;
        background-color: #FFD700;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 10px;
    }

    .info-item {
        font-family: 'Verdana', sans-serif;
        font-weight: normal;
        line-height: 1.5;
        color: #7f8c8d;
        font-size: 20px;
        margin: 5px 0;
        display: flex;
        justify-content: space-between;
    }

    .info-value {
        font-family: 'Verdana', sans-serif;
        font-size: 20px;
        line-height: 1.5;
        color: #7f8c8d;
        font-weight: bold;
    }

    .red-text {
        color: red;
    }

    .omok-container {
        background-color: #F5DEB3;
        border-collapse: collapse;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
        max-width: 80vw; /* 최대 너비 설정 */
        margin-bottom: 20px;
    }

    .omok-table {
        width: 100%;
        border-collapse: collapse;
    }

        .omok-table td {
            padding: 0;
        }

    .omok-button {
        width: 40px;
        height: 40px;
        padding: 0;
        border: 1px solid #ccc;
        background-color: transparent;
    }

        .omok-button:hover {
            cursor: pointer;
            border: 2px solid #000;
        }

    .stone-img {
        width: 100%;
        height: 100%;
    }

</style>